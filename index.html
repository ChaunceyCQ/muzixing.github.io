<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <title>Milestone</title>
    <meta name="description" content="">
    <meta name="author" content="muzi">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
    <script src="./theme/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="./theme/bootstrap.min.css" rel="stylesheet">
    <link href="./theme/bootstrap.min.responsive.css" rel="stylesheet">
    <link href="./theme/local.css" rel="stylesheet">
    <link href="./theme/pygments.css" rel="stylesheet">

</head>

<body>

<div class="navbar">
    <div class="navbar-inner">
    <div class="container">

         <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
             <span class="icon-bar"></span>
             <span class="icon-bar"></span>
             <span class="icon-bar"></span>
         </a>

        <a class="brand" href=".">Milestone</a>

        <div class="nav-collapse">

        <ul class="nav">
            
            <li><a href="./pages/about-me.html">About me</a></li>
        </ul>
	<form class="navbar-search pull-right" action="/search.html">
    	<input type="text" class="search-query" placeholder="Search" name="q" id="s">
</form>

        </div>
        
    </div>
    </div>
</div>

<div class="container">
    <div class="content">
    <div class="row">

        <div class="span9">
        

        


    <div class='article'>
        <div class="content-title">
            <a href="./pages/2014/10/28/openvirtexoperation-and-subsystems.html"><h1>OpenVirteX：Operation and Subsystems</h1></a>
2014-10-28

by <a class="url fn" href="./author/muzi.html">muzi</a>
 


 
        </div>
        
        <div><h2>前言</h2>
<p>继上篇<a href="http://www.muzixing.com/pages/2014/10/23/openvirtexwen-dang-xiang-jie-overview-and-components.html">《OpenVirteX文档概述（一）：Overview and Components》</a>之后，本篇将继续介绍OVX的Operation and Subsystems部分。主要讲述OVX内部的运作原理，本文属于个人简介，有误之处敬请指出，希望对读者有所帮助。本篇的顺序依然是按照官网文档的顺序介绍。</p>
<h2>简介</h2>
<p>本部分将介绍OVX内部的工作原理，如哪些内部子系统实现了哪一些功能，从而使得OVX能支持OpenFlow网络的虚拟化。以下的内容将分为如下的小点介绍：</p>
<ul>
<li>System Overview</li>
<li>Startup and Shutdown</li>
<li>The Event Loops</li>
<li>Network Discovery and Presentation</li>
<li>Virtualization and De-virtualization</li>
<li>State Synchronization</li>
<li>Reslience</li>
<li>persistence</li>
<li>The JSONRPC API</li>
</ul>
<h2>System Overveiw</h2>
<p>OVX分为以下几个主要的部分：</p>
<ul>
<li>一半是面向南向物理基础设施的部分 ，管理了datapath到OVX之间的OpenFlow通道，并建立和维持了一系列数据结构，用于描述物理基础网络。</li>
<li>另一半是面向北向租户控制器的部分，向租户控制器提供由OVXSwicth等组成的虚拟网络，并维护好OVX到各个租户控制器的OpenFlow通道。</li>
<li>Global maps则保存了物理设施到OVXNetwork的component之间的映射关系，完成PhysicalNetwork到OVXNetwork之间的桥接路由（其实就是映射）。</li>
<li>JSON的API用于配置和获取系统的信息。</li>
</ul>
<p>Global mapping是在OVXNetwork被创建的时候完成的，两段channel的管理也在不同的IO Loop中完成配置，使得从datapath到tenant controller的两段OpenFlow channel 能够正确对接成一条完整的controller channel。每一个需要被路由到OVXNetwork，或者需要横跨南北两部分的数据包都要在loop中调用virtualize()或者devirtualize()函数以完成消息的转换。由于global map的存在，使得底层物理网络和租户的虚拟网络之间的状态可以解耦，从而使得OVXNetwork可以在运行状态下动态地改变网络，也让OVX可以在没有任何租户网络的情况下控制底层网络。</p>
<h2>Startup and Shutdown</h2>
<p>这部分将要介绍的是OVX启动和关闭时OVX内部的程序运作流程。分为以下4个小节：</p>
<ul>
<li>Main process startup</li>
<li>PhysicalNetwork / Southbound channel initialization</li>
<li>Tenant Network (OVXNetwork) / Northbound channel initialization</li>
<li>System shutdown</li>
</ul>
<h3>Main process startup</h3>
<p>OVX的入口方法在<strong>OpenVirteX.java[package net.onrc.openvirtex.core]</strong>文件,通过解析命令行的输入参数来启动OpenVirteXController,OpenVirteXController完成了OVX核心的启动，也完成了环境变量，OVX参数等系统配置和初始化。启动的内容包括：</p>
<ul>
<li>初始化单一的PhysicalNetwork实例，用于描述底层物理网络。</li>
<li>尝试连接数据库，恢复数据库中先前存在虚网。</li>
<li>启动API服务，接受API调用。</li>
<li>初始化南向的通道处理函数，监听网络事件。</li>
</ul>
<p>第三步的时候，OVX监听API调用，第四步时，监听来自datapaths的连接。</p>
<h3>PhysicalNetwork population / Southbound channel initialization</h3>
<p>交换机连接到OVX以及链路发现的数据都记录到了PhysicalNetwork中。OVX为每一个交换机创建了一个PhysicalSwitch和SwitchDiscoveryManger的对象，用户描述交换机。此时OVX对于交换机而言，就是一个控制器。以下的图形象地描述了OVX在处理datapath连接时的状态变化。</p>
<p><img alt="" src="http://ovx.onlab.us/wp-content/uploads/2014/04/ClientFSM.png" /></p>
<p>Fig.1:OVX的南向与datapath握手的状态机示意图</p>
<p>如果对这个经典的OpenFlow协议的状态机不熟悉，可以参考<a href="http://www.muzixing.com/pages/2013/12/12/yuan-chuang-openflowtong-xin-liu-cheng-jie-du.html">《OpenFlow通信流程解读》</a></p>
<p><strong>SwitchChannelHandler [net.onrc.openvirtex.core.io]</strong>将这个状态机设置成枚举类型的ChannelState,每一个状态都有对应的方法去处理当前状态下的事件和消息。</p>
<p>当datapath达到WAIT_DESCRIPTION_STAT_REPLY之后，OVX才能将datapath映射成一个PhysicalSwitch。利用datapath提供的信息，OVX可以对datapath对应的PhysicaiSwitch进行配置，并将其加入到PhysicalNetwork中。当SwitchDiscoveryManager找到datapath的PhysicalNetwork，并且PhysicalSwitch的statisticsManager开启之后，datapath进入ACTIVE状态。当datapath进入ACTIVE状态时，datapath将参与到网络发现和OVX的事件循环当中，此时的datapath是一个正常运行状态的交换网桥。</p>
<h3>Tenant network (OVXNetwork) / Northbound channel initialization</h3>
<p>一个租户的网络的创建、配置和初始化都通过API的调用，其中步骤包括：</p>
<ul>
<li>
<p>Declare an OVXNetwork, the Address block used, and tenant controller(s) to  </p>
</li>
<li>
<p>connect the OVXNetwork to</p>
</li>
<li>
<p>Create OVXSwitches from available PhysicalSwitches</p>
</li>
<li>
<p>Add OVXPorts to the OVXSwitches</p>
</li>
<li>
<p>Add OVXLinks, Hosts, and for BVSes, SwitchRoutes</p>
</li>
<li>
<p>If manual, specify paths for OVXLinks and SwitchRoutes</p>
</li>
<li>
<p>Optionally, add backup paths for OVXLinks and SwitchRoutes</p>
</li>
<li>
<p>Initialize the OVXNetwork</p>
</li>
</ul>
<p>以上的步骤完成之后，OVX需要将其components初始化，并将virtual components映射到PhysicalNetwork components，并记录在global map中。然后将虚拟的components状态置为ACTIVE,在这种非常具有强制依赖性的顺序之下，最终完成OVXNetwork的初始化。具体的API都写在了<strong>API server [net.onrc.openvirtex.api.server]</strong>中，他们在<strong>tenant handlers [api.server.handlers.tenant]</strong>中被调用。具体的接口函数此处不加赘述，读者可到官网查看，也可以直接查看源码。下图描述了OVX中tenant Network的创建过程：
<img alt="" src="http://ovx.onlab.us/wp-content/uploads/2014/04/VnetInit.jpg" /></p>
<p>每一个Component都包含有register()和boot()的接口函数用于注册和初始化component。容易意识到的一点是，这些Component的启动肯定是有顺序的，或者说他们之间的以来关系肯定是固定的。如端口必然以来于交换机，没有交换机类，就不会有端口类。下图介绍了Components之间的包含和映射关系。其中实线为包含关系，虚线为映射关系。</p>
<p><img alt="" src="http://ovx.onlab.us/wp-content/uploads/2014/04/dependencies.png" /></p>
<p><strong>ControllerChannelHandler [net.onrc.openvirtex.core.io]</strong>  负责OVXSwitch实例到tenant controller的连接，并维持一个状态机如下图所示。当且仅当一个OVXNetwork完成了所有OVXSwitch和控制器的连接时，才能进入ACTIVE状态。此时的OVX对于tenant Controller而言是一个datapath。</p>
<p><img alt="" src="http://ovx.onlab.us/wp-content/uploads/2014/04/ServerFSM.png" /></p>
<h3>System shutdown</h3>
<p><strong>OpenVirtexShutdownHook [net.onrc.openvirtex.core.io]</strong>调用 OpenVirteXController.terminate()方法完成系统的关闭。这个方法关闭了面向租户和面向datapath两端的channel，也注销了PhysicalNetwork。</p>
<h2>The Event Loops</h2>
<p>这部分将介绍OVX的I/O loop。</p>
<h3>Overview</h3>
<p>OVX event loop主要用于处理OpenFlow messages。主要完成如下三个功能：</p>
<ul>
<li>负责OVX与datapath、OVX和tenant controller的OpenFlow协议通信。</li>
<li>完成OpenFlow messages的virtualize()和devirtualize():主要是将来自datapath的OpenFlow消息重写，路由到对应的租户控制器以及反向的消息转换。</li>
<li>保持OVX和datapath、OVX和tenant controller的连接。</li>
</ul>
<h3>Message handling and (de)virtualization</h3>
<p>OVXMessages部署了以下的两个接口中任意一个或者全部：</p>
<p><strong>Virtualizable</strong>: virtualize(PhysicalSwitch sw) : controller-bound messages</p>
<p><strong>Devirtualizable</strong> : devirtualize(OVXSwitch sw) : network-bound messages</p>
<p>这两个接口函数的参数都是switch类的子类。对于那些没有必要跨越virtual-physical gap的消息，就没有这些方法，如keep alive的消息（echo-request and echo-reply）。而那些需要从datapath一直交付到tenan controller的消息就必须要这写方法了，如flow_mod。</p>
<p>这些方法在handleIO()调用。handleIO()是PhysicalSwitch和OVXSwitch类中abstract method。</p>
<div class="highlight"><pre><span class="nv">@Override</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">handleIO</span><span class="p">(</span><span class="n">OFMessage</span> <span class="n">msg</span><span class="p">,</span> <span class="n">Channel</span> <span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">this</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">handleIO</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>当交换机处于ACTIVE状态时，才会被调用。</p>
<p>PhysicalPhysicalSwitch.Switchstate.ACTIVE满足时，handleIO允许被调用。函数代码如下：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">void</span> <span class="n">handleIO</span><span class="p">(</span><span class="n">PhysicalSwitch</span> <span class="n">psw</span><span class="p">,</span> <span class="n">final</span> <span class="n">OFMessage</span> <span class="n">msg</span><span class="p">,</span> <span class="n">Channel</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">try</span> <span class="p">{</span>
        <span class="p">((</span><span class="n">Virtualizable</span><span class="p">)</span> <span class="n">msg</span><span class="p">)</span><span class="o">.</span><span class="n">virtualize</span><span class="p">(</span><span class="n">psw</span><span class="p">);</span>
    <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="n">final</span> <span class="n">ClassCastException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">psw</span><span class="o">.</span><span class="nb">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Received illegal message : &quot;</span> <span class="o">+</span> <span class="n">msg</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>OVXSwitch.Switchstate.ACTIVE满足时，函数代码如下：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">void</span> <span class="n">handleIO</span><span class="p">(</span><span class="n">OVXSwitch</span> <span class="n">vsw</span><span class="p">,</span> <span class="n">final</span> <span class="n">OFMessage</span> <span class="n">msg</span><span class="p">,</span> <span class="n">Channel</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">/*</span>
     <span class="o">*</span> <span class="n">Save</span> <span class="n">the</span> <span class="n">channel</span> <span class="n">the</span> <span class="n">msg</span> <span class="n">came</span> <span class="n">in</span> <span class="n">on</span>
     <span class="o">*/</span>
    <span class="n">msg</span><span class="o">.</span><span class="n">setXid</span><span class="p">(</span><span class="n">vsw</span><span class="o">.</span><span class="n">channelMux</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">getXid</span><span class="p">(),</span> <span class="n">ch</span><span class="p">));</span>
    <span class="n">try</span> <span class="p">{</span>
        <span class="o">/*</span>
         <span class="o">*</span> <span class="n">Check</span> <span class="n">whether</span> <span class="n">this</span> <span class="n">channel</span> <span class="p">(</span><span class="n">ie</span><span class="o">.</span> <span class="n">controller</span><span class="p">)</span> <span class="n">is</span> <span class="n">permitted</span>
         <span class="o">*</span> <span class="n">to</span> <span class="nb">send</span> <span class="n">this</span> <span class="n">msg</span> <span class="n">to</span> <span class="n">the</span> <span class="n">dataplane</span>
         <span class="o">*/</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">vsw</span><span class="o">.</span><span class="n">roleMan</span><span class="o">.</span><span class="n">canSend</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="p">)</span>
            <span class="p">((</span><span class="n">Devirtualizable</span><span class="p">)</span> <span class="n">msg</span><span class="p">)</span><span class="o">.</span><span class="n">devirtualize</span><span class="p">(</span><span class="n">vsw</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">vsw</span><span class="o">.</span><span class="n">denyAccess</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">vsw</span><span class="o">.</span><span class="n">roleMan</span><span class="o">.</span><span class="n">getRole</span><span class="p">(</span><span class="n">ch</span><span class="p">));</span>
    <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="n">final</span> <span class="n">ClassCastException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">OVXSwitch</span><span class="o">.</span><span class="nb">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Received illegal message : &quot;</span> <span class="o">+</span> <span class="n">msg</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>其整个event loop（事件循环）示意图如下：</p>
<p><img alt="" src="http://ovx.onlab.us/wp-content/uploads/2014/07/io_main-622x1024.png" /></p>
<p>从上图中我们可以看到一些细节部分，比如来自租户的LLDP数据包是不会发送到datapath的。直接在OVX查询topology的数据结构就可以模拟出LLDP的效果了。同样OVX不断的在发送LLDP数据包，而packet_in数据类型而LLDP时，不会交给租户的控制器，而是由OVX的拓扑发现模块去处理，事实上，OVX就是一个控制器！只不过，它比控制器多出来虚拟化的功能，从而将网络的管理权，交给了各个租户的控制器而已。蓝色部分是面向租户的，橙色部分是面向datapath的，而中间的淡绿色部分是global部分。通过调用virtualize()和devirtualize()函数和使用global map数据完成消息的转换。</p>
<h3>Network Discovery and Presentation</h3>
<p>为了保证虚拟化的准确性，OVX必须保证获取到实时的网络试图，这就需要做以下的事情：</p>
<ul>
<li>探测拓扑和流表的变化</li>
<li>将拓扑变化对应地修改到PhysicalNetwork和PhysicalSwitch数据结构中。</li>
<li>检测拓扑变化是否对租户的虚网有影响，有则更新租户虚网拓扑信息。</li>
</ul>
<p>这一部分需要注意的一个重点是，OVX对网络拓扑，特别是对虚网拓扑的处理。按常规思路，直接下发转发tenan controller的LLDP数据包，和上传LLDP的packet_in是最简单的。但是代价就是会增加OVX的IO压力，给网络增加过多的流量。优化方法就是由OVX代理获取物理拓扑，而对于租户的拓扑探测请求则直接通过查询OVX的拓扑信息返回，这样就可以使得来自租户控制器的大量LLDP数据包在OVX上就得到回复，从而模拟了拓扑发现过程。</p>
<h4>Topology discovery/LLDP handling</h4>
<p><strong>Physical LLDP handling</strong></p>
<p>每一个PhysicalNetwork的SwitchDiscoveryManager负责处理LLDP消息。其处理流程如下图：</p>
<p><img alt="" src="http://ovx.onlab.us/wp-content/uploads/2014/04/SDMgr-loop-1024x807.png" /></p>
<p>根据每一个端口的探测计数器结果（默认为3），可以将端口分为fast和slow端口。其中fast端口为内部端口，即端口对端也是一个交换机端口，能回复LLDP数据包。否则就是slow端口，理论上slow端口为连接主机的端口。每一次发送一个探测包，探测计数器就加1，收到回复则减1，当计数器大于3时，可将端口定义为slow port，这些数据都存储在Map<Short, AtomicInteger> portProbeCount。</p>
<h4>PhysicalSwitch Statistics Collection</h4>
<p>在OVX中统计信息存储在如下的数据结构中：</p>
<div class="highlight"><pre><span class="n">AtomicReference</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Short</span><span class="p">,</span> <span class="n">OVXPortStatisticsReply</span><span class="o">&gt;&gt;</span> <span class="n">portStats</span><span class="p">;</span>
<span class="n">AtomicReference</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">List</span><span class="o">&gt;&gt;</span> <span class="n">flowStats</span><span class="p">;</span>
</pre></div>


<p>OVX通过<strong>StatisticsManager[net.onrc.openvirtex.elements.datapath.statistics]</strong>来获取统计信息。</p>
<p><strong>Physical flow table synchronization</strong></p>
<p>OVX通过周期地发送statisticsRequest来收集网络的统计信息，并存储在PhysicalSwitch.flowStats之中。具体的实现可以查看<strong>StatisticsManager[net.onrc.openvirtex.elements.datapath.statistics]</strong>等模块。</p>
<h3>OVXNetwork Presentation</h3>
<p><strong>Virtual topology presentation</strong>OVX通过查找OVX拓扑数据，来回复租户的拓扑发现请求，从而显著减少了LLDP消息在物理网络中的传播。其中步骤为：</p>
<ul>
<li>查找neighborPortMap表中destination port的数据</li>
<li>将结果封装成LLDP报文的packet_in并发送给租户控制器。</li>
</ul>
<p>下图介绍了这个处理流程。</p>
<p><img alt="" src="http://ovx.onlab.us/wp-content/uploads/2014/04/topology-resolution-1024x616.png" /></p>
<p>OVX目前还没有做关于租户多控制器的实现。</p>
<h2>Network Virtualization</h2>
<p>本部分将介绍OVX的核心模块，网络虚拟化模块，主要完成virtual&lt;---&gt;physical之间的映射转换。主要完成源目地址的修改，接入端口的翻译，OF消息的翻译等内容。具体的实现将分为以下几部分介绍。</p>
<ul>
<li>Switch Representation Translation</li>
<li>OpenFlow field translation – Cookies, Buffer IDs, XIDs</li>
<li>Address virtualization</li>
<li>Link and Route virtualization</li>
</ul>
<h3>Switch Representation Translation</h3>
<ul>
<li>
<p><strong>OVXSwitch -&gt; PhysicalSwitch (Southbound)</strong></p>
<p>通过拦截从tenant controller发向datapath的消息，以in_port为键值查找对应的PhysicalPort,从而找到对应的物理交换机，也可以通过tenant ID的方式查找OVXMap。具体实现，读者需要自行查看源码。</p>
</li>
<li>
<p><strong>PhysicalSwitch -&gt; OVXSwitch (Northbound)</strong></p>
<p>上行数据的查找可以直接通过MAC地址来查找，因为主机的MAC地址是唯一属于一个虚网的，所以可以作为key，用于查找tenantID，从而实现转换。也可以通过OpenFlow协议的消息字段，如xid，来找到某一个controller channel，而一个controller channel将对应一个租户的控制器。</p>
</li>
</ul>
<h3>OpenFlow field translation – Cookies, Buffer IDs, XIDs</h3>
<p>那些需要从datapath到租户控制器的OpenFlow消息都需要就行翻译。需要翻译的OpenFlow消息的字段包括cookies,buffer_id,xid等。</p>
<p><strong>XIDTranslator.XID</strong>需要在datapath上唯一，这个是OpenFlow协议的规定。而OVX在翻译消息的构成中，需要将来自datapath的xid以及生成的xid的键值对存储下来，以便在反向通信时，还原成原来的数据，保证通信的正确性。这个工作由XidTranslator.translate()完成，其中包括以下几个步骤：</p>
<ul>
<li>generates a new XID</li>
<li>creates an XidPair to store the original XID and source OVXSwitch</li>
<li>stores the XidPair in xidMap, using the new XID as the key</li>
<li>returns the new XID value to the caller</li>
</ul>
<p>反向的处理则由XidTranslator.untranslate()负责。</p>
<p><strong>OVXFlowTable</strong>是以cookie为键值存储在OVX上的。而这个cookie的产生由generateCookie() 函数负责。每一个cookie的编码都有tenantID参与，保证在OVX上cookie的唯一性以及导向性。</p>
<div class="highlight"><pre><span class="n">private</span> <span class="n">long</span> <span class="n">generateCookie</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">...</span>
        <span class="n">final</span> <span class="nb">int</span> <span class="n">cookie</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">cookieCounter</span><span class="o">.</span><span class="n">getAndIncrement</span><span class="p">();</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">long</span><span class="p">)</span> <span class="n">this</span><span class="o">.</span><span class="n">vswitch</span><span class="o">.</span><span class="n">getTenantId</span><span class="p">()</span> <span class="o">&amp;</span><span class="ow">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="ow">lt</span><span class="p">;</span> <span class="mi">32</span> <span class="o">|</span> <span class="n">cookie</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p><strong>bufferMap</strong>在packet_in/packet_out数据中，他们共用一个buffer_id。在消息的转换过程中，需要将来自packet_in的buffer_id和生成的buffer_id存起来，当packet_out数据下发时，则需要查找，并转换。</p>
<h3>Address virtualization</h3>
<p><strong>地址虚拟化是OVX中非常关键的部分</strong>。为了允许用户使用任意的IP，OVX定义了OVXIPAddress用于描述用户定义的IP，这个IP地址在虚网内是唯一的。OVX还定义了PhysicalIPAddress,用于描述底层物理的IP地址，这个地址在物理网络中是唯一的。在数据层面的通信中，OVX需要将边源端口的入口流量重写IP地址成PhysicalIPAddress,还需要重写边源端口的出流量数据的IP，转换成OVXIPAddress,从而向租户展现一个使用了租户定义地址的通信流程。而中间的转发过程，也即在core datapath的转发过程中，一直都是使用PhysicalIPAddress的，且其转发等行为也由OVX直接完成了。</p>
<p>为了完成这个工作，OVX将datapath分为两种：</p>
<ul>
<li>core datapath:仅和datapath相连的内部datapath,没有host挂载。</li>
<li>edge datapath:连接有host的datapath。</li>
</ul>
<p>对于edge datapath而言，OVX需要作如下两件事情：</p>
<ul>
<li>对于来自网络侧的流量，查询映射表，将PhysicalIPAddress重写成OVXIPAddress.</li>
<li>对于来自主机测的流量，查询映射表，将OVXIPAddress重写成PhysicalIPAddress.</li>
</ul>
<p>下图举例介绍了一个简单的通信流程：</p>
<p><img alt="" src="http://ovx.onlab.us/wp-content/uploads/2014/07/addr_virt.png" /></p>
<p>图中蓝色部分为使用OVXIPAddress通信的部分，橙色部分为使用PhysicalIPAddress通信的部分。其中:</p>
<ul>
<li>a为packet_in过程，直接发送给tenant controller;</li>
<li>b是packet_out过程，b过程需要将OVXIPAddress重写成PhysicalIPAddress;</li>
<li>c过程是core datapath的控制过程，直接由OVX完成，不需要上传给tenant controller，如果在虚妄中并没有这个交换机的存在的话。</li>
<li>d过程是对端edge datapath的packet_in过程，上传到OVX上时，需要转换成OVXIPAddress,进行虚拟化转换，才能转发给tenant controller。</li>
<li>e过程为packet_out过程，OVX需要将PhysicalIPAddress重写成OVXIPAddress。</li>
</ul>
<h4>Implementations</h4>
<p>以下介绍哪一些消息需要转换。</p>
<p><strong>PhysicalIPAddress -&gt; OVXIPAddress:</strong></p>
<ul>
<li>OVXPacketIn</li>
</ul>
<p><strong>OVXIPAddress -&gt; PhysicalIPAddress:</strong></p>
<ul>
<li>OVXPacketOut</li>
<li>OVXFlowMod</li>
<li>OVXActionNetworkLayerSource/Destination</li>
</ul>
<p>以下图片举例介绍了virtualize和devirtualize的流程：</p>
<p><img alt="" src="http://ovx.onlab.us/wp-content/uploads/2014/04/PacketIn.png" /></p>
<p><strong>PacketIn virtualization</strong></p>
<p><img alt="" src="http://ovx.onlab.us/wp-content/uploads/2014/04/PacketOut-1024x682.png" /></p>
<p><strong>PacketOut devirtualization</strong></p>
<p><img alt="" src="http://ovx.onlab.us/wp-content/uploads/2014/04/FlowMod-1024x863.png" />
<strong>FlowMod devirtualization</strong></p>
<h3>Link and Route virtualization</h3>
<p>TODO</p>
<h2>State Synchronization</h2>
<h3>Error Escalation</h3>
<p>OVX通过获取到网络的错误来同步PhysicalNetwork，如某一个port Down掉了，那么在PhysicalNetwork就应该更新其状态，并把与之对应的link down掉。这些状态变化依赖于PortStatus消息，这些消息的处理由<strong>OVXPortStatus [net.onrc.openvirtex.messages]</strong>负责。</p>
<p>OVX拥有错误消除的能力，能在一定范围内，隐藏底层网络中发生的错误事件，及时调整策略，保障租户的虚网正常运行。如一个BVS（Big Virtual Switch）中有一条链路发生故障，OVX可以重新映射一条没有人使用的备用链路，从而向租户隐藏错误。而对于普通的链路，OVX也可以将故障的OVXLink重新映射到冗余的链路上，保障网络的连通性。以下举例说明：</p>
<p><img alt="" src="http://ovx.onlab.us/wp-content/uploads/2014/04/err_ignore.png" /></p>
<ul>
<li>左边的图中，b,c两点并没有映射到租户的虚网中，所以OVX完全向租户控制器隐藏了这些错误，当然租户的控制器才不关心这些不属于他的交换机到底什么状态。</li>
<li>中间的图，a,d两点之间有多条path,当且仅当，所有的path都down掉，OVX才会通知租户控制器这一事件。</li>
<li>右边的图中，当a到b的SwitchRoute都down掉时，才会向租户上报错误。</li>
</ul>
<h3>Flow Table State Synchronization</h3>
<p><strong>OVXFlowTable Synchronization</strong></p>
<p>来自tenant controller的flow_mod在进行devirtualize()转换之前，需要存储在OVX上。tenant controller查看流表信息时，直接查看的就是存储在OVX上的流表信息。OVX始终为通过<strong>OVXFlowMods [net.onrc.openvirtex.messages]</strong>来为OVXSwitch保存着一个实时更新的flow table。</p>
<div class="highlight"><pre><span class="sr">/* Within class OVXFlowMod */</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">devirtualize</span><span class="p">(</span><span class="n">final</span> <span class="n">OVXSwitch</span> <span class="n">sw</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="n">FlowTable</span> <span class="n">ft</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">sw</span><span class="o">.</span><span class="n">getFlowTable</span><span class="p">();</span>
    <span class="o">...</span>
    <span class="n">long</span> <span class="n">cookie</span> <span class="o">=</span> <span class="p">((</span><span class="n">OVXFlowTable</span><span class="p">)</span> <span class="n">ft</span><span class="p">)</span><span class="o">.</span><span class="n">getCookie</span><span class="p">();</span>
    <span class="sr">//</span><span class="n">Store</span> <span class="n">the</span> <span class="n">virtual</span> <span class="n">flowMod</span> <span class="ow">and</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">physical</span> <span class="n">cookie</span>
    <span class="n">ovxMatch</span><span class="o">.</span><span class="n">setCookie</span><span class="p">(</span><span class="n">cookie</span><span class="p">);</span>
    <span class="sr">/* update sw&#39;s OVXFlowTable */</span>
    <span class="n">boolean</span> <span class="n">pflag</span> <span class="o">=</span> <span class="n">ft</span><span class="o">.</span><span class="n">handleFlowMods</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>
</pre></div>


<p><strong>OVXFlowTable.handleFlowMods()</strong>根据flow_mod的command类型来修改对应的流表项。</p>
<p>在虚拟的流表被更新之后，OVX将把这个更新下发到datapath，实时修改datapath的流表。</p>
<p><strong>Physical flow table synchronization</strong> 
datapath的flow table信息被记录在PhysicalSwitch.flowStats数据结构中。每一个PhysicalSwitch实例中的<strong>StatisticsManager [net.onrc.openvirtex.elements.datapath.statistics]</strong>负责周期地发送 OFFlowStatisticsRequests来获取统计数据，普遍的可以设置为30秒为刷新周期。</p>
<p><strong>Synchronization between flow tables</strong></p>
<p>physical flow table和virtual flow table的同步通过virtualize()函数和devirtualize()函数实现。具体代码实现如下：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">void</span> <span class="n">virtualize</span><span class="p">(</span><span class="n">final</span> <span class="n">PhysicalSwitch</span> <span class="n">sw</span><span class="p">)</span> <span class="p">{</span>
    <span class="sr">/* determine tenant from cookie */</span>
    <span class="nb">int</span> <span class="n">tid</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">cookie</span> <span class="o">&amp;</span><span class="ow">gt</span><span class="p">;</span><span class="o">&amp;</span><span class="ow">gt</span><span class="p">;</span> <span class="mi">32</span><span class="p">);</span>
    <span class="o">...</span>
    <span class="n">try</span> <span class="p">{</span>
        <span class="sr">/* find which OVXSwitch&#39;s flowtable is affected */</span>
        <span class="n">OVXSwitch</span> <span class="n">vsw</span> <span class="o">=</span> <span class="n">sw</span><span class="o">.</span><span class="n">getMap</span><span class="p">()</span><span class="o">.</span><span class="n">getVirtualSwitch</span><span class="p">(</span><span class="n">sw</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vsw</span><span class="o">.</span><span class="n">getFlowTable</span><span class="p">()</span><span class="o">.</span><span class="n">hasFlowMod</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">cookie</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">OVXFlowMod</span> <span class="n">fm</span> <span class="o">=</span> <span class="n">vsw</span><span class="o">.</span><span class="n">getFlowMod</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">cookie</span><span class="p">);</span>
            <span class="n">vsw</span><span class="o">.</span><span class="n">deleteFlowMod</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">cookie</span><span class="p">);</span>
            <span class="sr">/* send north ONLY if tenant controller wanted a FlowRemoved for the FlowMod*/</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fm</span><span class="o">.</span><span class="n">hasFlag</span><span class="p">(</span><span class="n">OFFlowMod</span><span class="o">.</span><span class="n">OFPFF_SEND_FLOW_REM</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">writeFields</span><span class="p">(</span><span class="n">fm</span><span class="p">);</span>
            <span class="n">vsw</span><span class="o">.</span><span class="n">sendMsg</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">sw</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</pre></div>


<h2>Resilience</h2>
<p>网络中的网元肯定是会有down掉的时候的。为了减少这些底层设施的failures影响到租户的网络，OVX采用了冗余映射的方式，解决这一问题，主要包括以下的方面：</p>
<ul>
<li>
<p>OVXLinks : multiple paths</p>
</li>
<li>
<p>SwitchRoute : multiple paths</p>
</li>
<li>
<p>OVXBigSwitch : multiple SwitchRoutes, sets of PhysicalSwitches, or SwitchRoutes with multiple paths</p>
</li>
</ul>
<p>当某一个冗余映射的component发生故障时，他就可以通过调用<strong>Resilient[net.onrc.openvirtex.elements]</strong>接口完成故障恢复。这个接口提供了以下连个方法：</p>
<ul>
<li>
<p>public boolean tryRecovery(Component c) : Given the failure of c, attempt to switch over to any backup mappings, if possible</p>
</li>
<li>
<p>public boolean tryRevert(Component c) : Given the resumed function of c, attempt to switch back to the original (favored) mapping</p>
</li>
</ul>
<p>以下将两个过程介绍了link故障和linkh恢复的过程。</p>
<p><img alt="" src="http://ovx.onlab.us/wp-content/uploads/2014/04/tryRecovery.png" /></p>
<p>从上图可以看出，当physical link failed时,OVX将在查找他的备份链路，试图重新映射，并把以前的流表导入到新的link相关的switch中，同时还需要将failed的link加入到broken set，将重新映射的link从backup list中删除。</p>
<p><img alt="" src="http://ovx.onlab.us/wp-content/uploads/2014/04/tryRevert.png" /></p>
<p>上图介绍了链路恢复的过程。当之前failed的link重新恢复之后，OVX将自动尝试将映射恢复到原来的链路上，这包括流表的倒换等操作。这时需要注意的是链路的优先级问题，假设原先的链路具有最高优先级，这能让问题变得简单一些。</p>
<h2>Persistence</h2>
<p>本部分将介绍OVX中关于配置持续性的描述。OVX使用数据库存储用户的配置信息，并实时更新信息。当OVX重启时，能通过读取用户信息，迅速恢复租户的虚网。不仅仅包括虚网的拓扑，还包括所有的ID(tenantID, DPID等等)</p>
<h3>Configuration Parameters</h3>
<table class="table-bordered table-striped table-condensed">
<tr>
    <td><b>Option</b></td>
    <td><b>Argument</b></td>
    <td><b>Comments</b></td>
</tr>
<tr>
    <td>-dh or –db-host</td>
    <td>hostname</td>
    <td>default: "127.0.0.1"</td>
</tr>
<tr>
    <td>-dp or –db-port</td>
    <td>port</td>
    <td>default:27017</td>
</tr>
</table>

<p>值得注意的是，当虚网没有提前进行配置时，会出现以下的问题：</p>
<ul>
<li>
<p>If OVX can’t connect to the database: Currently, this generates error messages in the log. These messages won’t interfere with the regular operation of OVX.</p>
</li>
<li>
<p>Using the option “–db-clear”: All persistence data is deleted from storage.</p>
</li>
</ul>
<h3>Related Packages and Classes</h3>
<p>由于笔者对数据库不了解，所以这部分不做详细介绍，详情读者可以到官网查看文档。</p>
<h4>class DBManager</h4>
<p><strong>Fields</strong></p>
<div class="highlight"><pre><span class="sr">//</span> <span class="n">Database</span> <span class="n">collection</span> <span class="n">names</span>
<span class="n">public</span> <span class="n">static</span> <span class="n">final</span> <span class="n">String</span> <span class="n">DB_CONFIG</span> <span class="o">=</span> <span class="s">&quot;CONFIG&quot;</span><span class="p">;</span>
<span class="n">public</span> <span class="n">static</span> <span class="n">final</span> <span class="n">String</span> <span class="n">DB_USER</span> <span class="o">=</span> <span class="s">&quot;USER&quot;</span><span class="p">;</span>
<span class="n">public</span> <span class="n">static</span> <span class="n">final</span> <span class="n">String</span> <span class="n">DB_VNET</span> <span class="o">=</span> <span class="s">&quot;VNET&quot;</span><span class="p">;</span>

<span class="sr">//</span> <span class="n">Database</span> <span class="n">object</span>
<span class="n">private</span> <span class="n">DBConnection</span> <span class="n">dbConnection</span><span class="p">;</span>

<span class="sr">//</span> <span class="n">Map</span> <span class="n">of</span> <span class="n">collection</span> <span class="n">names</span> <span class="ow">and</span> <span class="n">collection</span> <span class="n">objects</span>
<span class="n">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">DBCollection</span><span class="o">&gt;</span> <span class="n">collections</span><span class="p">;</span>

<span class="sr">//</span> <span class="n">Mapping</span> <span class="n">between</span> <span class="n">physical</span> <span class="n">dpids</span> <span class="ow">and</span> <span class="n">a</span> <span class="n">list</span> <span class="n">of</span> <span class="n">vnet</span> <span class="n">managers</span>
<span class="n">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Long</span><span class="p">,</span> <span class="n">List</span><span class="sr">&lt;OVXNetworkManager&gt;</span><span class="o">&gt;</span> <span class="n">dpidToMngr</span><span class="p">;</span>
<span class="sr">//</span> <span class="n">Mapping</span> <span class="n">between</span> <span class="n">physical</span> <span class="n">links</span> <span class="ow">and</span> <span class="n">a</span> <span class="n">list</span> <span class="n">of</span> <span class="n">vnet</span> <span class="n">managers</span>
<span class="n">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">DPIDandPortPair</span><span class="p">,</span> <span class="n">List</span><span class="sr">&lt;OVXNetworkManager&gt;</span><span class="o">&gt;</span> <span class="n">linkToMngr</span><span class="p">;</span>
<span class="sr">//</span> <span class="n">Mapping</span> <span class="n">between</span> <span class="n">physical</span> <span class="n">ports</span> <span class="ow">and</span> <span class="n">a</span> <span class="n">list</span> <span class="n">of</span> <span class="n">vnet</span> <span class="n">managers</span>
<span class="n">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">DPIDandPort</span><span class="p">,</span> <span class="n">List</span><span class="sr">&lt;OVXNetworkManager&gt;</span><span class="o">&gt;</span> <span class="n">portToMngr</span><span class="p">;</span>
</pre></div>


<p><strong>Methods</strong></p>
<div class="highlight"><pre><span class="sr">//</span> <span class="n">Initialize</span> <span class="n">database</span> <span class="n">connection</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">init</span><span class="p">(</span><span class="n">String</span> <span class="n">host</span><span class="p">,</span> <span class="n">Integer</span> <span class="n">port</span><span class="p">,</span> <span class="n">boolean</span> <span class="n">clear</span><span class="p">)</span>

<span class="sr">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">document</span> <span class="n">in</span> <span class="n">database</span> <span class="n">from</span> <span class="n">persistable</span> <span class="n">object</span> <span class="n">obj</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">createDoc</span><span class="p">(</span><span class="n">Persistable</span> <span class="n">obj</span><span class="p">)</span>
<span class="sr">//</span> <span class="n">Remove</span> <span class="n">a</span> <span class="n">document</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">removeDoc</span><span class="p">(</span><span class="n">Persistable</span> <span class="n">obj</span><span class="p">)</span>

<span class="sr">//</span> <span class="n">Save</span> <span class="n">an</span> <span class="n">element</span> <span class="n">to</span> <span class="n">the</span> <span class="n">list</span> <span class="n">of</span> <span class="n">specified</span> <span class="n">key</span> <span class="n">in</span> <span class="n">document</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">save</span><span class="p">(</span><span class="n">Persistable</span> <span class="n">obj</span>
<span class="sr">//</span> <span class="n">Remove</span> <span class="n">an</span> <span class="n">element</span> <span class="n">from</span> <span class="n">the</span> <span class="n">list</span> <span class="n">of</span> <span class="n">specified</span> <span class="n">key</span> <span class="n">in</span> <span class="n">document</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">remove</span><span class="p">(</span><span class="n">Persistable</span> <span class="n">obj</span><span class="p">)</span>

<span class="sr">//</span> <span class="n">Reads</span> <span class="n">all</span> <span class="n">virtual</span> <span class="n">networks</span> <span class="n">from</span> <span class="n">database</span> <span class="ow">and</span> <span class="n">spawn</span> <span class="n">an</span> <span class="n">OVXNetworkManager</span>
<span class="sr">//</span> <span class="k">for</span> <span class="nb">each</span><span class="o">.</span>
<span class="n">private</span> <span class="n">void</span> <span class="n">readOVXNetworks</span><span class="p">()</span>

<span class="sr">//</span> <span class="n">Reads</span> <span class="n">virtual</span> <span class="n">components</span> <span class="n">from</span> <span class="n">a</span> <span class="n">list</span> <span class="n">of</span> <span class="n">maps</span> <span class="n">in</span> <span class="n">db</span> <span class="nb">format</span> <span class="ow">and</span> <span class="n">registers</span> <span class="n">the</span>
<span class="sr">//</span> <span class="n">physical</span> <span class="n">components</span> <span class="n">in</span> <span class="n">their</span> <span class="n">manager</span><span class="o">.</span>
<span class="n">private</span> <span class="n">void</span> <span class="n">readOVXSwitches</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="n">switches</span><span class="p">,</span>
                        <span class="n">OVXNetworkManager</span> <span class="n">mngr</span><span class="p">)</span>
<span class="n">private</span> <span class="n">void</span> <span class="n">readOVXLinks</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="n">links</span><span class="p">,</span>
                        <span class="n">OVXNetworkManager</span> <span class="n">mngr</span><span class="p">)</span>
<span class="n">private</span> <span class="n">void</span> <span class="n">readOVXPorts</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="n">ports</span><span class="p">,</span>
                        <span class="n">OVXNetworkManager</span> <span class="n">mngr</span><span class="p">)</span>
<span class="n">private</span> <span class="n">void</span> <span class="n">readOVXRoutes</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="n">routes</span><span class="p">,</span>
                        <span class="n">OVXNetworkManager</span> <span class="n">mngr</span><span class="p">)</span>
</pre></div>


<h4>class OVXNetworkManager</h4>
<p>OVXNetworkManager负责从数据库中恢复租户的虚网。</p>
<p><strong>Field</strong></p>
<div class="highlight"><pre><span class="sr">//</span> <span class="n">Document</span> <span class="n">of</span> <span class="n">virtual</span> <span class="n">network</span>
<span class="n">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">vnet</span><span class="p">;</span>

<span class="n">private</span> <span class="n">Integer</span> <span class="n">tenantId</span><span class="p">;</span>

<span class="sr">//</span> <span class="n">Set</span> <span class="n">of</span> <span class="n">offline</span> <span class="ow">and</span> <span class="n">online</span> <span class="n">physical</span> <span class="n">switches</span>
<span class="n">private</span> <span class="n">Set</span><span class="sr">&lt;Long&gt;</span> <span class="n">offlineSwitches</span><span class="p">;</span>
<span class="n">private</span> <span class="n">Set</span><span class="sr">&lt;Long&gt;</span> <span class="n">onlineSwitches</span><span class="p">;</span>

<span class="sr">//</span> <span class="n">Set</span> <span class="n">of</span> <span class="n">offline</span> <span class="ow">and</span> <span class="n">online</span> <span class="n">physical</span> <span class="n">links</span> <span class="n">identified</span> <span class="n">as</span> <span class="p">(</span><span class="n">dpid</span><span class="p">,</span> <span class="n">port</span> <span class="n">number</span><span class="p">)</span><span class="o">-</span><span class="n">pair</span>
<span class="n">private</span> <span class="n">Set</span><span class="sr">&lt;DPIDandPortPair&gt;</span> <span class="n">offlineLinks</span><span class="p">;</span>
<span class="n">private</span> <span class="n">Set</span><span class="sr">&lt;DPIDandPortPair&gt;</span> <span class="n">onlineLinks</span><span class="p">;</span>

<span class="sr">//</span> <span class="n">Set</span> <span class="n">of</span> <span class="n">offline</span> <span class="ow">and</span> <span class="n">online</span> <span class="n">physical</span> <span class="n">ports</span>
<span class="n">private</span> <span class="n">Set</span><span class="sr">&lt;DPIDandPort&gt;</span> <span class="n">offlinePorts</span><span class="p">;</span>
<span class="n">private</span> <span class="n">Set</span><span class="sr">&lt;DPIDandPort&gt;</span> <span class="n">onlinePorts</span><span class="p">;</span>

<span class="n">private</span> <span class="n">boolean</span> <span class="n">bootState</span><span class="p">;</span>
</pre></div>


<p><strong>Methods</strong></p>
<div class="highlight"><pre><span class="sr">//</span> <span class="n">Register</span> <span class="n">a</span> <span class="n">physical</span> <span class="n">component</span> <span class="n">to</span> <span class="n">offline</span> <span class="n">list</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">registerSwitch</span><span class="p">(</span><span class="n">final</span> <span class="n">Long</span> <span class="n">dpid</span><span class="p">)</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">registerLink</span><span class="p">(</span><span class="n">final</span> <span class="n">DPIDandPortPair</span> <span class="n">dpp</span><span class="p">)</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">registerPort</span><span class="p">(</span><span class="n">final</span> <span class="n">DPIDandPort</span> <span class="n">port</span><span class="p">)</span>

<span class="sr">//</span> <span class="n">Delete</span> <span class="n">a</span> <span class="n">physical</span> <span class="n">component</span> <span class="n">from</span> <span class="n">offline</span> <span class="n">list</span><span class="p">,</span>
<span class="sr">//</span> <span class="n">add</span> <span class="n">it</span> <span class="n">to</span> <span class="n">online</span> <span class="n">list</span><span class="p">,</span>
<span class="sr">//</span> <span class="ow">and</span> <span class="k">then</span><span class="p">,</span> <span class="k">if</span> <span class="n">all</span> <span class="n">physical</span> <span class="n">components</span> <span class="n">are</span> <span class="n">online</span><span class="p">,</span>
<span class="sr">//</span> <span class="n">create</span> <span class="n">a</span> <span class="n">virtual</span> <span class="n">network</span><span class="o">.</span>
<span class="n">public</span> <span class="n">synchronized</span> <span class="n">void</span> <span class="n">setSwitch</span><span class="p">(</span><span class="n">final</span> <span class="n">Long</span> <span class="n">dpid</span><span class="p">)</span>
<span class="n">public</span> <span class="n">synchronized</span> <span class="n">void</span> <span class="n">unsetSwitch</span><span class="p">(</span><span class="n">final</span> <span class="n">Long</span> <span class="n">dpid</span><span class="p">)</span>
<span class="n">public</span> <span class="n">synchronized</span> <span class="n">void</span> <span class="n">setLink</span><span class="p">(</span><span class="n">final</span> <span class="n">DPIDandPortPair</span> <span class="n">dpp</span><span class="p">)</span>
</pre></div>


<h4>Storing Configurations</h4>
<p>当虚网的component初始化之后，他们的信息将以文档的形式存入数据库。目前需要存在数据库中的component的如下所示：</p>
<ul>
<li>OVXNetwork</li>
<li>OVXSingleSwitch</li>
<li>OVXBigSwitch</li>
<li>OVXPort</li>
<li>OVXLink</li>
<li>SwitchRoute</li>
<li>Host</li>
</ul>
<h4>Mechanism</h4>
<p>当component初始化时，需要调用register()方法。在这个方法中，会调用DBManager.save()方法，用于将信息存储到数据库，其中包括：</p>
<ul>
<li>Gets target collection by getDBName() e.g. “VNET”</li>
<li>Gets query index by getDBIndex() e.g. { “tenantId”:1 }</li>
<li>Gets key by getDBKey() and value by getDBObject() e.g. key is “switches”, value is { “dpids”:[4], “vdpid”:400 }</li>
<li>Adds (updates) this value into the list of this key by using MongoDB’s $addToSet operator. If the initial set is {“switches”:[{“dpids”:[1], “vdpid”:100}]}, this becomes {“switches”:[{“dpids”:[1], “vdpid”:100}, {“dpids”:[4], “vdpid”:400}]}</li>
</ul>
<h4>Persistible Components</h4>
<p>OVXSwitch subclasses (OVXSingleSwitch, OVXBigSwitch), OVXLink, SwitchRoute, OVXPort and Host等class都具有persistible属性，都会将信息存储在数据库中。</p>
<h4>Updating (Deleting) Configurations</h4>
<p>当component发生更新时，OVX会创建新对象去描述这个新的component，同时也要把这些新数据存到数据库中。但是这个过程对于全部的component来说并不是统一的，分为以下两种情况：</p>
<ul>
<li>
<p><strong>OVXNetworks</strong> : DBManager.removeDoc() deletes a document of the specified virtual network. This method is called by OVXNetwork.unregister().</p>
</li>
<li>
<p><strong>Other Elements</strong> : DBManager.remove() deletes an element in the list of the value for specified key by the $pull operation of MongoDB. This method is called by component inactivation methods:</p>
<ul>
<li>unregisterDP() – OVXSwitch</li>
<li>unregister() – OVXPort, OVXLink, SwitchRoute, OVXHost</li>
</ul>
</li>
</ul>
<h4>Restoring Configurations</h4>
<p>当boot完成的时候，physical component是处于在offline状态的。OVX将去查询在offline list中的component是否还是offline，当OVX发现某一个physical element(物理网元)处于活跃状态时，将为其创建对应的physical component。当全部的physical element都处于active时，OVX将试图从数据库中恢复OVXNetwork</p>
<h2>后语</h2>
<p>原本我想写的是OVX的文档详解，但是目前看来好像写成了文档翻译。因为确实我对于OVX只是通过文档了解到了一些皮毛，没有更深的理解，写出来的文章缺乏主观的观点。这种问题在很久以前我已经意识到。我自己目前陷入一种非常尴尬的状态，对新知识渴望，但是却了解甚少。所以以后的时间可能需要专心读书，沉下心来好好学术。博客已经开了快一年了，但是一直以来写的都是偏工程的教程和代码详解等文章，其学术意义不大。现在也成为一个研究生了，还没有找到一个合适的节奏，希望在以下的学习生活中，能脚踏实地，加强点核心竞争力吧。谢谢浏览本博客的所有人！</p></div>
        <hr />
    </div>
		

 
        

 

    <div class='article'>
        <a href="./pages/2014/10/23/openvirtexwen-dang-xiang-jie-overview-and-components.html"><h2>OpenVirteX文档详解（一）——Overview and Components</h2></a>
        <div class= "well small"> 2014-10-23

by <a class="url fn" href="./author/muzi.html">muzi</a>
 


 </div>
        <div class="summary"><h2>前言</h2>
<p>本篇博文将按照OpenVirteX Documentation的顺序详细介绍OpenVirteX的相关内容。完整翻译版，请查看@北邮-张歌 翻译的文章。转载请声明出处。</p>
<h2>Overview</h2>
<p>OpenVirteX(以下简称OVX)是onlab开发的一个网络虚拟化平台，可以实现多租户的网络虚拟化。对于租户而言，需要在OVX上注册，申请资源，配置自己的网络，指定自己的控制器。剩下的工作就由OVX完成了。OVX可以根据租户的需求，将租户的网络拓扑映射到具体的物理拓扑上，完成网络的联通。对于租户而言，看到的是一个虚拟的网络，无法看到真实的物理拓扑，也不需要关心，即租户“认为”得到了一个属于自己的真实网络。而OVX的位置相当于一个介于租户控制器和交换机之间的转换平台。面对租户，OVX就是一个物理的网络，而面对交换机，OVX就是控制器。（这种转换平台的角色可以实现很多功能，不仅仅是网络虚拟化，还可以模拟许多信息，比如在某个项目中我们将OVS模拟成一个OTN的交换机，验证了一些想法）</p>
<h3>网络虚拟化</h3>
<p>网络虚拟化允许多租户占用同一个网络基础设施，同时允许租户对其网络的控制能力，对于租户而言，感觉上是自己控制了整个网络。OVX通过使租户能够获取到自己的虚拟拓扑和全网的地址空间来实现网络虚拟化。前者可以允许租户自定义网络拓扑，后者则是用于隔离不同租户的流量，防止冲突。</p>
<p>与flowspace的切分slice，使租户使用网络的一部分不一样的是 ...</p> <a class="btn btn-info xsmall" href="./pages/2014/10/23/openvirtexwen-dang-xiang-jie-overview-and-components.html">read more</a></div>
    </div>	
				

 
        

 

    <div class='article'>
        <a href="./pages/2014/10/19/ji-yu-sdnde-ryuying-yong-arp_proxy.html"><h2>基于SDN的RYU应用——ARP_PROXY</h2></a>
        <div class= "well small"> 2014-10-19

by <a class="url fn" href="./author/muzi.html">muzi</a>
 


 </div>
        <div class="summary"><h3>前言</h3>
<p>在传统网络中，存在着一定的广播流量，占据了一部分的网络带宽。同时，在有环的拓扑中，如果不运行某些协议，广播数据还会引起网络风暴，使网络瘫痪。传统的解决方案是运行STP（生成树协议），来解决环路带来的风暴隐患。但是这样的难题在SDN之后，解决起来似乎变得要简单一些。本文将介绍如何在控制器RYU上开发ARP代理模块，用于代理回复ARP请求，以及解决环状拓扑风暴的问题。</p>
<h3>算法逻辑</h3>
<p>具体的算法流程图如下：</p>
<div class="highlight"><pre>packet_in
    <span class="o">|</span>
    <span class="o">|</span>
  ARP learning
  MAC_to_Port learning
    <span class="o">|</span>
    <span class="o">|</span>
    <span class="o">|</span>               No  
Multicast? <span class="o">--------------------------------------------&gt;|</span>
    <span class="o">|</span>                                                   <span class="o">|</span>
    <span class="o">|</span> Yes                                               <span class="o">|</span>
    <span class="o">|</span>                                                   <span class="o">|</span>
    <span class="o">|</span>                                                   <span class="o">|</span>
    <span class="o">|</span>      No                                           <span class="o">|</span>
   loop? <span class="o">-----&gt;</span><span class="p">(</span>dpid<span class="p">,</span>eth_src<span class="p">,</span>dst_ip<span class="p">)</span>learning            <span class="o">|</span>
    <span class="o">|</span>                   <span class="o">|</span>                               <span class="o">|</span>
    <span class="o">|</span>                   <span class="o">|</span>                               <span class="o">|</span>
    <span class="o">|</span>                   <span class="o">|</span>               No              <span class="o">|</span>         No
    <span class="o">|</span>Yes        dst_ip in arp_table? <span class="o">-------&gt;</span>dst in mac_to_port? <span class="o">----&gt;</span>Flood
    <span class="o">|</span>                   <span class="o">|</span>                               <span class="o">|</span>               <span class="o">|</span>
    <span class="o">|</span>                   <span class="o">|</span>Yes                            <span class="o">|</span>Yes            <span class="o">|</span>
    <span class="o">|</span>                   <span class="o">|</span>                               <span class="o">|</span>               <span class="o">|</span>
   drop             ARP_REPLY                       flow_mod            <span class="o">|</span>
    <span class="o">|</span>                   <span class="o">|</span>                               <span class="o">|</span>               <span class="o">|</span>
    <span class="o">|</span>                   <span class="o">|</span>                               <span class="o">|</span>               <span class="o">|</span>
    <span class="o">|&lt;------------------|&lt;------------------------------|&lt;--------------|</span>               
    <span class="o">|</span>
    <span class="o">|</span>
    end
</pre></div>


<h3>解决环路风暴 ...</h3> <a class="btn btn-info xsmall" href="./pages/2014/10/19/ji-yu-sdnde-ryuying-yong-arp_proxy.html">read more</a></div>
    </div>	
				

 
        

 

    <div class='article'>
        <a href="./pages/2014/09/20/ryuru-men-jiao-cheng.html"><h2>RYU入门教程</h2></a>
        <div class= "well small"> 2014-09-20

by <a class="url fn" href="./author/muzi.html">muzi</a>
 


 </div>
        <div class="summary"><h3>前言</h3>
<p>辗转了POX,NOX,OpenDaylight等多个控制器之后，我终于意识到我只喜欢python语言的控制器。但是我依然记得OpenDaylight的Nullpointer的Exception,还记得YANG文件的深奥，但是OpenDaylight让我对控制器开发的兴趣减少了，这不是我想要的事情。最后，我下决定转向RYU。我突然发现，生活突然变得很美好。我用着我熟悉的，喜欢的，优美的python，写着充满美感的语句，犹如写诗一般的惬意。</p>
<p>本篇主要介绍如何安装RYU，和如何在RYU上开发APP。</p>
<h3>RYU的安装</h3>
<p>安装RYU，需要安装一些python的套件：</p>
<ul>
<li>python-eventlet</li>
<li>python-routes</li>
<li>python-webob</li>
<li>python-paramiko</li>
</ul>
<p>安装RYU主要有两种方式：</p>
<ul>
<li>
<p>pip安装</p>
<div class="highlight"><pre><span class="n">pip</span> <span class="n">install</span> <span class="n">ryu</span>
</pre></div>


</li>
<li>
<p>下载源文件安装</p>
<div class="highlight"><pre><span class="n">git</span> <span class="n">clone</span> <span class="n">git:</span><span class="sr">//gi</span><span class="n">thub</span><span class="o">.</span><span class="n">com</span><span class="sr">/osrg/</span><span class="n">ryu</span><span class="o">.</span><span class="n">git</span>
<span class="n">cd</span> <span class="n">ryu</span>
<span class="n">sudo</span> <span class="n">python</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">install</span>
</pre></div>


</li>
</ul>
<p>若还有更多问题 ...</p> <a class="btn btn-info xsmall" href="./pages/2014/09/20/ryuru-men-jiao-cheng.html">read more</a></div>
    </div>	
				

 
        

 

    <div class='article'>
        <a href="./pages/2014/09/17/qemuvirt-managerphoronix-test-suitefu-wu-qi-ce-shi.html"><h2>QEMU+virt-manager+phoronix-test-suite服务器测试</h2></a>
        <div class= "well small"> 2014-09-17

by <a class="url fn" href="./author/muzi.html">muzi</a>
 


 </div>
        <div class="summary"><h3>前言</h3>
<p>这是研究生开学的第一个任务，学习测试服务器性能。首先我们需要在一台新服务器上面安装ubuntu12.04，这个步骤很简单。安装完之后，可以使用top命令查看系统的cpu,mem等性能指标。然后我们就需要安装phoronix-test-suite，用于测试服务器的某些性能。接下来，使用qemu安装虚拟机，在虚拟机有负载的情况下，继续测量服务器的性能。</p>
<h3>PHORONIX-TEST-SUITE</h3>
<p>这是一个相当牛逼的服务器测试工具：[phoronix-test-suite]:http://www.phoronix-test-suite.com/</p>
<p>下载安装：http://get.ubuntusoft.com/app/phoronix-test-suite</p>
<p>先将安装包下载到本地，然后解压。进入phoronix-test-suite目录，运行install_sh进行安装。</p>
<p>安装之后可以通过</p>
<div class="highlight"><pre><span class="n">phoronix</span><span class="o">-</span><span class="n">test</span><span class="o">-</span><span class="n">suite</span>  <span class="n">list</span><span class="o">-</span><span class="n">available</span>
</pre></div>


<p>查看可使用的测试列表。</p>
<p>选择某一个测试项进行测试</p>
<div class="highlight"><pre><span class="n">phoronix</span><span class="o">-</span><span class="n">test</span><span class="o">-</span><span class="n">suite</span>  <span class="n">benchmark</span> <span class="o">&lt;</span><span class="n">test</span> <span class="n">name</span><span class="o">&gt;</span>
</pre></div>


<p>如：</p>
<div class="highlight"><pre><span class="n">phoronix</span><span class="o">-</span><span class="n">test ...</span></pre></div> <a class="btn btn-info xsmall" href="./pages/2014/09/17/qemuvirt-managerphoronix-test-suitefu-wu-qi-ce-shi.html">read more</a></div>
    </div>	
				
<div class="pagination">
<ul>
    <li class="prev disabled"><a href="#">&larr; Previous</a></li>

    <li class="active"><a href="./index.html">1</a></li>
    <li class=""><a href="./index2.html">2</a></li>
    <li class=""><a href="./index3.html">3</a></li>
    <li class=""><a href="./index4.html">4</a></li>
    <li class=""><a href="./index5.html">5</a></li>
    <li class=""><a href="./index6.html">6</a></li>
    <li class=""><a href="./index7.html">7</a></li>
    <li class=""><a href="./index8.html">8</a></li>

    <li class="next"><a href="./index2.html">Next &rarr;</a></li>

</ul>
</div>
 
  
        </div>
        
        <div class="span3">

            <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
            <ul class="nav nav-list">
                <li class="nav-header"> 
                Site
                </li>
            
                <li><a href="./archives.html">Archives</a>
                <li><a href="./tags.html">Tags</a>
                <li><a href="http://www.muzixing.com/" rel="alternate">Atom feed</a></li>
                <li><a href="http://www.muzixing.com/feeds/all.rss.xml" rel="alternate">RSS feed</a></li>
            </ul>
            </div>


            <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
            <ul class="nav nav-list">
                <li class="nav-header"> 
                Categories
                </li>
                
                <li><a href="./category/life.html">life</a></li>
                <li><a href="./category/tech.html">Tech</a></li>
                   
            </ul>
            </div>


            <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
            <ul class="nav nav-list">
                <li class="nav-header"> 
                Links
                </li>
            
                <li><a href="http://www.sdnlab.com/">SDNLAB</a></li>
                <li><a href="http://www.sdnap.com/">sdnap</a></li>
                <li><a href="http://www.richardzhao.me/">Richardzhao</a></li>
                <li><a href="http://ikimi.net/">Kimi Yang</a></li>
            </ul>
            </div>


            <div class="social">
            <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
            <ul class="nav nav-list">
                <li class="nav-header"> 
                Social
                </li>
           
                <li><a href="https://github.com/muzixing">github</a></li>
                <li><a href="http://350959853.qzone.qq.com">qzone</a></li>
            </ul>
            </div>
            </div>

        </div>  
    </div>     </div> 
<footer>
<br />
<p><a href=".">Milestone</a> &copy; muzi 2012</p>
</footer>

</div> <!-- /container -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script src="http://twitter.github.com/bootstrap/assets/js/bootstrap-collapse.js"></script>
<script>var _gaq=[['_setAccount','UA-45955656-1'],['_trackPageview']];(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.src='//www.google-analytics.com/ga.js';s.parentNode.insertBefore(g,s)}(document,'script'))</script>
 
</body>
</html>